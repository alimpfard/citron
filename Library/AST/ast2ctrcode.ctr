import Library/Data/SwitchCase.

#:language XFrozen

var ast2ctrcode is {:self:ast:curindent:options
  options is options or: Map.
  var max_line_length is options at: 'max_line_length', or: 80.
  var indent_s        is ' ' * (options at: 'indent_length', or: 2).
  var pkwmsgs         is options at: 'parenthesize_kwmsgs', or: False.
  curindent is curindent or: 0.
  ^(frozen __ is
    case: 'LTRNUM' do: {
      ^ast value.
    },
    case: 'LTRSTRING' do: {
      var value is ast value.
      ^'\'%s\'' % [value escapeAsciiControls escape: '\'\n'].
    },
    case: 'LTRNIL' do: {
      ^'Nil'.
    },
    case: 'LTRBOOLTRUE' do: {
      ^'True'.
    },
    case: 'LTRBOOLFALSE' do: {
      ^'False'.
    },
    case: 'REFERENCE' do: {
      var value is ast value.
      ^(frozen __ is
        case: 'My'     do: {\ 'my %s' },
        case: 'Var'    do: {\ 'var %s' },
        case: 'Const'  do: {\ 'const %s' },
        case: 'Frozen' do: {\ 'frozen %s' },
        default: {\ '%s' }) switch: ast modifier, % [value].
    },
    case: 'EXPRMESSAGE' do: {
      var rec is self[ast @ 0, curindent, options].
      var ct is ast count.
      ct - 1 times: {:i
        var s is ast @ (i + 1).
        var rv is ' ' + self[s, curindent, options].
        (rec length > max_line_length) ifTrue: {
          (rec split: '\n', last) length + rv length > max_line_length ifTrue: {
            rec +=: '\n'.
          }.
        }.
        rec +=: rv.
        i !=: ct - 2, & (s type = 'KWMESSAGE') ifTrue: {
          pkwmsgs ifTrue: {
            &&rec is '(${{rec}}$)'.
          } ifFalse: {
            rec +=: ','.
          }.
        } ifFalse: {
          pkwmsgs ifTrue: {
            &&rec is '(${{rec}}$)'.
          }.
        }.
      }.
      ^rec.
    },
    case: 'UNAMESSAGE' do: {
      ^ast value.
    },
    case: 'BINMESSAGE' do: {
      ^ast value + ' ' + self[ast @ 0, curindent, options].
    },
    case: 'KWMESSAGE' do: {
      var value is ast value split: ':'.
      var code is Array < ''.
      value each: {:i:x
        var tc is '%s: %s ' % [x, self[ast @ i, curindent + 1, options]].
        var tchead is tc split: '\n', head.
        (code last length + tchead length > max_line_length) ifTrue: { # ...\n <code> <tc>
          code push: ''.
        }.
        code last +=: tc.
      }.
      var indent is indent_s * (curindent + 1).
      code is (code join: '\n' + indent).
      ^code rightTrim.
    },
    case: 'EXPRASSIGNMENT' do: {
      var ref is self[(ast at: 0), curindent, options].
      var _value is self[(ast at: 1), curindent, options].
      ^_value length > 0 either: { ^'%s is %s' % [ref, _value]. } or: ref.
    },
    case: 'SYMBOL' do: {
      ^$!ast.
    },
    case: 'NESTED' do: {
      var code is '('.
      var ps is ast at: 0.
      var tcode is self[ps, (curindent +=: 1), options].
      tcode length > max_line_length ifTrue: { code +=: '\n' + (indent_s * curindent). }.
      code +=: tcode.
      ^code + ')'.
    },
    case: 'CODEBLOCK' do: {
      var ps is ast at: 0.
      var ins is ast at: 1.
      var fmt is ast modifier = 'My' either: '{\\%:L%s%:L\n%s}' or: '{%:L%s%:L\n%s}'.
      var cindent is '\n' + (indent_s * (curindent +=: 1)).
      ^fmt % ['',
              (Array new fill: ps count with: \:x ':' + (ps @ x) value),
              cindent,
              cindent,
              (Array new fill: ins count with: \:x self[ins @ x, curindent, options] + '.'),
              indent_s * (curindent - 1)
            ].
    },
    case: 'PROGRAM' do: {
      ^(Array new fill: ast count with: \:x self[ast @ x, curindent + 1, options] + '.') join: '\n' + (indent_s * curindent).
    },
    case: 'ENDOFPROGRAM' do: { ^''. },
    case: 'RETURNFROMBLOCK' do: { ^'^' + self[ast @ 0, curindent, options]. },
    case: 'IMMUTABLE' do: {
      var code is Array < '['.
      var ps is ast at: 0.
      var pcount is ps count.
      var newlined is False.
      (Array new fill: pcount with: \:i self[ps @ i, curindent, options]) each_v: {:gen
        var tcode is code last + gen + ', '.
        tcode split: '\n', last length > max_line_length ifTrue: {
          code unshift: (indent_s * (curindent + 1)) + (code shift skip: 1).
          code unshift: '['.
          code push: (indent_s * (curindent + 1)) + gen + ', '.
          newlined is True.
        } ifFalse: { code last +=: gen + ', '. }.
      }.
      pcount > 0 ifTrue: { code put: (code last from: 0 to: code last length - 2) at: code count - 1. }.
      code last split: '\n', last length > max_line_length ifTrue: { code push: ''. }.
      newlined ifTrue: {
        code push: (indent_s * curindent) + ']'.
      } ifFalse: {
        code last +=: ']'.
      }.
      ^code filter_v: \:x x trim length, join: '\n'.
    },
    case: 'RAW' do: {
      ^((frozen _ is
          case: 'None' do: {\ '%s'},
          case: 'My'   do: {\ '$(%s)'},
          default:         {
            ^'%s'.
          }
        ) switch: ast modifier) % [self[ast @ 0, curindent, options]].
    },
    case: 'EMBED' do: {
      var qq is ast at: 0.
      ^'$`(' + self[qq, curindent, options] + ')'.
    },
    case: 'LISTCOMP' do: {
      var expr is ast at: 0.
      var generator is ast at: 1.
      var noptions is options copy put: True at: 'parenthesize_kwmsgs'.
      var gencode is ''.
      {
        var pcount is generator count.
        (Array new fill: pcount with: \:i self[generator @ i, curindent, noptions]) each_v: {:gen
          var tgencode is gencode + gen + ', '.
          tgencode split: '\n', last length > max_line_length ifTrue: { tgencode is gencode + '\n' + (indent_s * (curindent + 1)) + gen + ', '. }.
          gencode is tgencode.
        }.
        pcount > 0 ifTrue: { gencode is gencode from: 0 to: gencode length - 2. }.
        gencode split: '\n', last length > max_line_length ifTrue: { gencode +=: '\n'. }.
      } catch: {}, run.
      var predcode is ''.
      {
        var predicate is ast at: 2.
        var pcount is predicate count.
        (Array new fill: pcount with: \:i self[predicate @ i, curindent, noptions]) each_v: {:gen
          var tpredcode is predcode + gen + ', '.
          tpredcode split: '\n', last length > max_line_length ifTrue: { tpredcode is predcode + '\n' + (indent_s * (curindent + 1)) + gen + ', '. }.
          predcode is tpredcode.
        }.
        pcount > 0 ifTrue: { predcode is predcode from: 0 to: predcode length - 2. }.
        predcode split: '\n', last length > max_line_length ifTrue: { predcode +=: '\n'. }.
      } catch: { }, run.
      var exprv is '[${{self[expr, curindent, options]}}$'.
      gencode = '' ifFalse: {
        var exprvb is exprv + ''.
        exprv +=: ',, ' + gencode.
        exprv split: '\n', last length > max_line_length ifTrue: {
          exprv is '${{exprvb}}$,,\n${{indent_s * (curindent + 1)}}$$$gencode'.
        }.
      }.
      predcode = '' ifFalse: {
        var exprvb is exprv + ''.
        exprv +=: ',, ' + predcode.
        exprv split: '\n', last length > max_line_length ifTrue: {
          exprv is '${{exprvb}}$,,\n${{indent_s * (curindent + 1)}}$$$predcode'.
        }.
      }.
      exprv +=: ']'.
      ^exprv.
    },
    default: { errPen red writeln: '$$ast is not unparsable at the moment ( because of $$value )', resetColor. }) switch: ast type.
}.
