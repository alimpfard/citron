#!/usr/bin/env ctr
#:language XFrozen

Broom autoAlloc: True.
Reflect ignoreInTrace: (Program argument: 1). #eval or whatever it is
#Pen write: 'Extensions: ' + (File extensionsPath), brk.
Broom memoryLimit: 1024 * 1024 * 1024 * 4.

var PIDFILE is '~/.ctrpid.pid'.
var logo is ?>  _____ _ _
 / ____(_) |
| |     _| |_ _ __ ___  _ __
| |    | | __| '__/ _ \| '_ \  %s
| |____| | |_| | | (_) | | | |
 \_____|_|\__|_|  \___/|_| |_|

%s %s<?.

var display_logo is True.

var GREEN_COLOR is 'green' toSymbol.
var ITALIC_EFFECT is 'italic' toSymbol.
var inp is ''.
var _ is Nil.
var __ is Nil.
var it is Nil.
var stderr is File special: 'stderr'.
var inBlock is 0.
var inBlockNew is 0.
var enterRepeat is False.
var TerminalWidth is 85.

import
  Library/Data/Map
  Library/Data/Set
  Library/Utils/Highlight
  Library/Control/MethodResolve
  Library/Data/String
  Library/Data/IO/UTF-8/input
  Library/System/File/Temp
  Library/System/system: { system => Csystem. }
  Library/Functional/LazyBoolean: ['and', 'or']
  Library/Prelude: \*
  Library/Data/Array/LRArray: 'LRArray'
  Library/Utils/CLIContextMenu: ['generate_context_menu', 'clear_next_line', 'write_next_line', 'move_cursor']
  Library/Data/IO/Pen: 'pPen'.

#:declare lazyev or
#:declare lazyev and

var OneGateFlipper is Object new on: 'new' do: { ^me cnew: {my value is False.}. }.
OneGateFlipper on: 'set' do: { my value is True. }.
OneGateFlipper on: 'get' do: { var v is my value. my value is False. ^v. }.
Pen is pPen for: (File special: 'stdout').
var errPen is Pen for: stderr.
var linesp is 1.

Eval is Object new.
Eval on: 'init' do: {
  my end is False.
  my color is 'resetColor'.
  my prompt is '⠕ '.
  my args is Array new.
  my allowedColors is ('red blue magenta cyan yellow green resetColor' split: ' ') join: '|'.
  my globalvars is False.
  my history is LRArray new init: 100.
  my histdir is '~/.citron'.
  my hs_file is Nil.
  my commands is Nil.
  my command_comps is Nil.
  my userDefs is Nil.
  my continuation is '⠒⠂'.
  genAccessors: ['evaluatorObject', 'completerObject'].
  my evaluatorObject is me. # self-ref for ::'evaluate:'
  my completerObject is me. # self-ref for ::'complete:withToc:'
  my flags is Map new
    put: False at: 'ptype',
    put: False at: 'stats',
    put: True at: 'printvs',
    put: True at: 'highlight',
    put: False at: 'paste',
    put: False at: 'equit',
    put: False at: 'jsonout',
    put: True at: 'intty',
    put: True at: 'processig',
    put: False at: 'clear_errors',
    put: True at: 'history',
    put: False at: 'html_colors',
    put: False at: 'searching',
    put: False at: 'searchfailed'.
  me genReader: 'eServer'.
  my errd is False.
  my last_error is Nil.
  my inNewBlock is False.
  my breakpoints is Map new.
  my debug is False.
  my stepDebug is False.
  my returnValue is Array new.
  my evaluationContext is Map new
    on: 'toString' do: {^'[GlobalEvalContext]'.}.
  my displayObject is Pen. #override from commandline, maybe?
  my printObject   is Pen.
  ^me.
}.
Eval on: 'initHistory' do: {
  (var hddir is File new: my histdir) exists ifFalse: { hddir mkdir. }.
  my hs_file is File new: my histdir + '/ctrhist'.
  my hs_file exists ifFalse: { my hs_file write: ''. }.
  var history is my history.
  (my hs_file read split: '\n\n\n') each_v: \:x history push: x.
}.
Eval on: 'print' do: {
  ^my printObject.
}.
Eval on: 'print:' do: {:x
  my printObject is x.
}.
Eval on: 'display' do: {
  ^my displayObject.
}.
Eval on: 'display:' do: {:x
  my displayObject is x.
}.
['clear', 'green', 'cyan', 'magenta',
 'purple', 'blue', 'yellow', 'resetColor',
 'red', 'brk', 'clearLine', 'write:',
 'writeln:']
 each_v: {:v
   Eval on: 'display/$$v' do: {:*args
     ^my displayObject message: const v arguments: args.
   }.
}.
['clear', 'green', 'cyan', 'magenta',
 'purple', 'blue', 'yellow', 'resetColor',
 'red', 'brk', 'clearLine', 'write:',
 'writeln:']
 each_v: {:v
   Eval on: 'print/$$v' do: {:*args
     ^my printObject message: const v arguments: args.
   }.
}.

Eval on: 'disambiguateError:' do: {:e
  getFlag: 'clear_errors', ifFalse: { ^[e, '']. }.
  e isA: String, ifFalse: { ^e. }.
  e is e + ''.
  e startsWith: 'Key not found: "', ifTrue: {
    ^[e, 'Try \'%s\' to create a string' % [(e skip: 16, ~ 's/"$//')]].
  }.
  e startsWith: 'Key not found: ', ifTrue: {
    var key is e skip: 15, trim lower.
    var names is Eval allTheNames.
    names is names filter: \:_:v v lower = key.
    ^names count > 0 either: {
      ^[e, (names count = 1 either: 'Did you mean %L?' or: 'Did you mean one of (%L)?') % [names]].
    } or: [e, ''].
  }.
  e = 'Invalid bind' ifTrue: {
    ^[e, 'Check your assignment target (typevar/pattern)'].
  }.
  ^[e, ''].
}.
Eval on: 'handleException:' do: {:self:e
  my errd is True.
  my last_error is e.
  ^me getFlag: 'equit', either: {thisBlock error: e.} or: {
    var dis is self disambiguateError: e.
    self display/red write: (dis last either: ('%s\n\t' + Colors reset + 'Tip: ' + Colors magenta + '%s') or: '%s%s', % dis), resetColor brk.
    ^e.
  }.
}.
Eval on: 'handleInternalException:' do: {:e
  (var bugtrack is File new: '~/.citron/citron_eval_bug_track') exists ifFalse: {
    File mkdir: bugtrack path.
  }.
  var oldp is Program changeDirectory: bugtrack realPath.
  File new: 'citron_eval_bug_track_%s' % [Clock new time], write: '%s\nTime %s\n===========================\n%s' % [e, Clock new, (Reflect lastTrace tail tail tail chunks: 2, fmap: (\:x x join: ' at '), join: '\n')].
  errPen writeln: 'Eval bug, $$e'.
  Program changeDirectory: oldp.
}.
Eval on: 'errored?' do: {^my errd.}.
Eval on: 'lastError' do: {^my last_error.}.
Eval on: 'trace' do: {^Reflect lastTrace.}.
Eval on: 'end' do: {
  my end is True.
  my debug ifFalse: {
    me stopEvalServer.
    getFlag: 'history', & my hs_file isNil not ifTrue: {
      my hs_file write: (
        my history join: '\n\n\n'
      ).
    }.
  }.
}.
Eval on: 'break' do: { my end ifTrue: {Broom sweep.}. ^my end. }.
Eval on: 'allowedColors' do: { ^my allowedColors. }.
Eval on: 'isAllowedColor:' do: { :c
  ^(c containsPattern: my allowedColors).
}.
Eval on: 'setColor:' do: { :c
  (me isAllowedColor: c) ifFalse: { thisBlock error: 'value $$c' + ' is not an allowed color.'. }.
  my color is c.
}.
Eval on: 'setPrompt:' do: { :p my prompt is p. }.
Eval on: 'setContinuation:' do: { :p my continuation is p. }.
Eval on: 'setArgs:' do: { :a my args is a. }.
Eval on: 'args' do: { ^my args. }.
Eval on: 'color' do: { ^my color. }.
Eval on: 'prompt' do: { ^(me preprompt) + my prompt + (me proprompt). }.
Eval on: 'preprompt' do: {
  var pp is Array new.
  me getFlag: 'highlight', ifFalse: { pp push: 'p'. }.
  me getFlag: 'searching', ifTrue: {
    pp push: 's' + (getFlag: 'searchfailed', either: '-failing' or: '').
  }.
  pp is pp join: ':'.
  ^pp length > 0 either: pp + ' ' or: pp.
}.
Eval on: 'proprompt' do: {
  ^me inNewBlock either: ' ' * 2 * inBlock or: ''.
}.
Eval on: 'inNewBlock' do: {^my inNewBlock.}.
Eval on: 'newBlock' do: { my inNewBlock is True. }.
Eval on: 'endBlock' do: { my inNewBlock is False. }.
Eval on: 'continuation' do: { ^my continuation. }.
Eval on: 'evalContext' do: { ^my evaluationContext. }.
Eval on: 'shiftArgs' do: { ^my args shift. }.
Eval on: 'enableFlag:' do: {:flag my flags put: True at: flag. }.
Eval on: 'disableFlag:' do: {:flag my flags put: False at: flag. }.
Eval on: 'getFlag:' do: {:flag ^my flags at: flag. }.
Eval on: 'toggleFlag:' do: {:flag my flags put: (my flags @ flag) not at: flag. }.
Eval on: 'flags' do: {^my flags. }.
Eval on: 'modifyFlags:' do: {:flag
  flag startsWith: 'no-', ifTrue: {
    me disableFlag: (flag skip: 3).
  }, else: {
    me enableFlag: flag.
  }.
}.
Eval on: 'histdir:' do: {:q my histdir is q. }.
Eval on: 'argCount' do: { ^(my args count). }.
Eval on: 'onlyRelevantArgs' do: {
    my args do shift shift done.
}. #get rid of ./ctr eval

Eval on: 'startEvalServer' do: {
  var port is 5000 + (Dice rollWithSides: 1000).

  var EvalServer is Eval new init.

  my eServer is Program new: {:p
      Program is p.
      File new: PIDFILE, write: Program pid.
      p port: port.
      p serve_ipv4: EvalServer.
  }.

  ^port.
}.

Eval on: 'startEvalServerOnPort:' do: {:port

  var EvalServer is Eval new init.

  my eServer is Program new: {:p
      Program is p.
      File new: PIDFILE, write: Program pid.
      p port: port.
      p serve: EvalServer.
  }.

  ^port.
}.

Eval on: 'stopEvalServer' do: {
  ^my eServer isNil not either: {my eServer signal: 1. ^True.} or: {^False.}.
}.

Eval on: 'addUserDef:definition:' do: {:name:def
  me userDefs put: def at: name.
}.

Eval on: 'userDefs' do: {
  ^my userDefs is my userDefs or: {
    ^Map new.
  }.
}.

Eval genAccessors: 'nextInput'.

Eval on: 'returnValue:' do: {:x my returnValue do pop push: x, done. }.
Eval on: 'stepDebug:' do: {:x my stepDebug is x. }.
Eval on: 'debug' do: { ^my debug. }.

Eval on: 'Commands' do: {
  my commands is my commands or: {
    var c is Map new
      put: {:args Eval end. ^''.} at: 'q',
      put: {:args Eval modifyFlags: args. ^''.} at: '!f',
      put: {:args Eval modifyFlags: args ~ ?>s/^-/no-/g<? ~ ?>s/^\+//g<?. ^''.} at: 'set',
      put: {:args ^Reflect strTypeOf: (Eval evaluatorObject evaluate: args).} at: 't',
      put: {:args ^(args trim = '') either: {^Eval startEvalServer.} or: {^Eval startEvalServerOnPort: (Eval evaluatorObject evaluate: args).}.} at: 'server',
      put: {:args ('#:declare %s %d %s\n\n0' % (args reSplit: '\\s+')) eval. ^''.} at: '!fix',
      put: {:args ^'Interpreter metacommands help:
      + q -- Quit
      + t <expression> -- type of expression
      + server [<port>] -- make an eval server on port <port>, or a random port.
      + !server -- kill the eval server
      + !m <expression> -- evaluates and shows the methods of expression.
      + !p <expression> -- evaluates and shows the properties of expression.
      + !f <[no-]flag> -- modifies flag
      + last [(<nth>)] <query> -- sets the next input to the last (nth if provided) match in history
      + !last [n] -- sets the next input to the last nth expression in history
      + hist [(<nth>)] <query> -- searches for entry in history, and returns it as a block
      + !hist [(<nth>)] <query> -- searches and executes (like hist but executes immediately)
      + list <{hist}> [n] -- lists the last n items in history
      + !repeat [-<stride>] <count> -- execute the last count expressions starting at stride?0 items up
      + set <(+|-)flag> -- alternative for !f with easier(?) syntax
      + !def <name> <expression> -- create a metacommand
      + p <expression> -- prints the value of expression
      + c -- clear screen and history
      + break <obj> <msg> -- break on object\'s message
      + !enable <b[reak]> -- enable option
      + % <...> -- line comment in REPL (ignores args)
      + h -- show this help
      - ! <cmd> -- execute shell command
      - :{\\n stmt* \\n:}\\n -- block expression'
      + '\nDebug Mode commands (Currently Experimental):
      + !return <value> -- return value for this message
      + !step -- single step through messages
      + !cont -- continue
      + !frame [show, all, <id>] -- show frames'
      + '\nUser-defined commands:
      ' + (Eval userDefs fmap: \:k:v '+ %s -- %s' % [k, v], values join: '\n', or: '-None-')
      + '\nKeybindings:
      + tab
        attempt code completion in edit mode
      + enter
        run code if complete, otherwise newline (in edit mode)
      + <C-c>
        break out of all blocks if in edit mode
        interrupt running code if running
      + <C-d>
        Immediately exit REPL anywhere in edit mode
      + <C-l>
        clear screen in edit mode
      + F2
        enter or exit paste mode'.} at: 'h',
      put: {^Eval stopEvalServer.} at: '!server',
      put: {:args ^Reflect getPropertiesOf: (Eval evaluatorObject evaluate: args).} at: '!p',
      put: {:args Eval display/writeln: (Eval evaluatorObject evaluate: args). ^''.} at: 'p',
      put: {:args Eval display/clear. (var h is Eval getHistory) count times: { h pop. }. ^''.} at: 'c',
      put: {:args ^Reflect getMethodsOf: (Eval evaluatorObject evaluate: args).} at: '!m',
      put: {:args AST pragma: args trim. ^''.} at: '!pragmaOnce',
      put: {^''.} at: '%',
      put: {:args
        var msgs is args reSplit: '\\s+'.
        var obj is Eval evaluatorObject evaluate: msgs head.
        msgs tail each_v: \:msg Eval breakFor: obj message: msg.
        ^'will break on messages %L' % [msgs].
      } at: 'break',
      put: {:args
        args startsWith: 'b', either: {
          Eval instrument.
        } or: {
          thisBlock error: 'Invalid option $$args'.
        }.
        ^''.
      } at: '!enable',
      put: {:args
        Eval debug ifTrue: {
          Eval returnValue: (Eval evaluatorObject evaluate: args).
          Eval end.
        }.
        ^''.
      } at: '!return',
      put: {
        Eval debug ifTrue: {
          Eval stepDebug: False.
          Eval end.
        }.
        ^''.
      } at: '!continue',
      put: {
        Eval debug ifTrue: {
          Eval stepDebug: True.
          Eval end.
        }.
        ^''.
      } at: '!step',
      put: {:argstr
        import Library/AST/ast2ctrcode: 'ast2ctrcode'.
        var f is File tempFile: '/tmp/XXXXXX.ctr'.
        f open: 'w+'.
        f write: '# Write your code in here\n# and close the editor when done\n'.
        f close.
        Csystem['${{Program env: 'EDITOR', or: 'vim'}}$ "${{f path escapeDoubleQuotes}}$"'].
        var code is AST parse: '{\n' + f read + '\n} run.'.
        var source is ast2ctrcode[code].
        Eval pushHist: source.
        ^Eval evaluatorObject evaluate: (source from: 0 to: source length - 1).
      } at: 'edit',
      put: {:argstr
        var nth is 0.
        var cmd is 'Nil.'.
        argstr findPattern: ?>(?:\((\d+|\*)\))?\s*(.+)$<? do: {:groups
          nth is groups at: 1.
          nth = '*' ifTrue: { nth is -1. }, ifFalse: { nth is nth toNumber. }.
          cmd is groups at: 2.
        }.
        cmd is Eval getHistory filter: {\:_:x x startsWith: cmd.}.
        cmd count = 0 ifTrue: {
          thisBlock error: 'No match found $$argstr'.
        }.
        nth is nth min: cmd count - 1.
        ^nth = -1 either: {
          Pen red writeln: 'Will execute: ', resetColor.
          Pen cyan write: '+ ', writeln: (cmd join: '\n+ '), resetColor.
          ^{\ cmd fmap: \:x x eval. }.
        } or: {
          cmd is cmd at: nth.
          Pen red writeln: 'Will execute: ', resetColor.
          Pen cyan writeln: cmd, resetColor.
          ^{\ cmd eval. }.
        }.
      } at: 'hist',
      put: {:argstr
        var nth is -1.
        var cmd is 'Nil.'.
        argstr findPattern: ?>(?:\((\d+|\*)\))?\s*(.+)$<? do: {:groups
          nth is groups at: 1.
          nth = '*' ifTrue: { nth is -1. }, ifFalse: { nth is nth toNumber. }.
          cmd is groups at: 2.
        }.
        cmd is Eval getHistory filter: {\:_:x x startsWith: cmd.}.
        cmd count = 0 ifTrue: {
          thisBlock error: 'No match found $$argstr'.
        }.
        nth is nth min: cmd count - 1.
        ^nth = -1 either: {
          Eval nextInput: cmd last.
          ^''.
        } or: {
          Eval nextInput: cmd @ nth.
          ^''.
        }.
      } at: 'last',
      put: {:argstr
        argstr is argstr trim.
        argstr = '' ifTrue: {
            Eval nextInput: Eval getHistory last.
            ^''.
        } ifFalse: {
            Eval nextInput: (Eval getHistory at: Eval getHistory count - 1 - argstr toNumber).
            ^''.
        }.
      } at: '!last',
      put: {:argstr
        var fs is argstr trim reSplit: '\\s+'.
        var first is fs shift.
        ^(frozen _ is String
            case: '' do: {
                ^'List what? {history}'.
            },
            case: 'h'
            case: 'hist'
            case: 'history' do: {
                var hist is Eval getHistory copy.
                var len is hist count min: (fs count = 0 either: (10) or: {^fs head toNumber.}).
                ^hist from: hist count - len length: len, reverse imap!: {\:i:x ((i + 1) toString paddingRight: 3) + '| ' + (x from: 0 to: [TerminalWidth - 6, x length] min).}, join: '\n'.
            },
            default: {
                ^'Unknown listing: $$first'.
            }) switch: first.
      } at: 'list',
      put: {:argstr
        var nth is 0.
        var cmd is 'Nil.'.
        argstr findPattern: ?>(?:\((\d+|\*)\))?\s*(.+)$<? do: {:groups
          nth is groups at: 1.
          nth = '*' ifTrue: { nth is -1. }, ifFalse: { nth is nth toNumber. }.
          cmd is groups at: 2.
        }.
        cmd is Eval getHistory filter: {\:_:x x startsWith: cmd.}.
        cmd count = 0 ifTrue: {
          thisBlock error: 'No match found $$argstr'.
        }.
        nth is nth min: cmd count - 1.
        ^nth = -1 either: {
          ^Reflect run: {:cmd:nth ^cmd fmap: \:x x eval. } inContextAsMain: Eval evalContext arguments: [cmd, nth].
        } or: {
          ^Reflect run: {:cmd:nth ^cmd at: nth, eval. } inContextAsMain: Eval evalContext arguments: [cmd, nth].
        }.
      } at: '!hist',

      put: {:argstr
        var stride is 0.
        var count is 0.
        var args is argstr reSplit: '[^-\\d]+'.
        args head startsWith: '-', ifTrue: {
          stride is args shift toNumber.
        }.
        args count = 0 ifTrue: {
          thisBlock error: 'Missing argument 0 (count) for !repeat'.
        }.
        count is args head toNumber.
        var hist is Eval getHistory.
        var chunk is hist from: hist count + stride - count length: count.
        chunk count > 0 ifTrue: {
          Pen writeln: 'Will now execute $$count expressions:\n\t%:L' % ['\n\t', (chunk fmap: \:x Highlight highlight: x)].
          var res is chunk fmap: {:x ^Eval evaluatorObject evaluate: x.}.
          ^res.
        }.
        ^''.
      } at: '!repeat',
      put: {:args
        var name is args reSplit: '\\s+'.
        ^Reflect run: {:name
          name count = 0 ifTrue: {
            ^Reflect frame: (Reflect frameId - 2).
          }.
          name is name head.
          ^(name case: 'show' do: {
              var s is Reflect frame: (Reflect frameId - 2), kvlist: \:kv [kv head, (Reflect strTypeOf: kv last), kv last], fmap: \:x '%s (%s) = %s' % x, join: ', '.
              ^'frame %d { %s }' % [Reflect frameId - 2, s].
          }, case: 'all' do: {
            var x is Array new.
            Reflect frameId - 1 times: ({:i
              x push: (Reflect frame: i + 1).
            } catch: {}).
            ^x imap: (\:i:f 'frame %d { %s }' % [i + 1, (f kvlist: \:kv [kv head, (Reflect strTypeOf: kv last), kv last], fmap: \:x '%s (%s) = %s' % x, join: ', ')]), join: '\n'.
          }, default: {
            ^Reflect frame: (name toNumber), kvlist: \:kv [kv head, (Reflect strTypeOf: kv last), kv last], fmap: \:x '%s (%s) = %s' % x, join: ', '.
          }, switch).
        } inContextAsMain: Eval evalContext arguments: [name].
      } at: '!frame',
      put: {:args
        [name, fn] is args split: ' ' max: 1.
        Eval addUserDef: name definition: fn.
        Eval addMetaCommand: name function: (Eval evaluatorObject evaluate: fn).
        ^'+def %s %s' % [name, fn].
      } at: '!def'.
    c on: 'get:' do: {:self:cmd
      ^me at: cmd, or: {
        ^(cmd containsPattern: '^\\W$')
         either: Nil
         or: {
          var candidates is self keys filter: \:_:c c startsWith: cmd.
          ^candidates count
            case: 0 do: { ^Nil. },
            case: 1 do: { ^self at: candidates head. },
            default: {
              var candidates2 is candidates filter: \:_:x (x = cmd).
              ^candidates2 count
                case: 1 do: { ^self at: candidates2 head. },
                default: { ^\:args 'Ambiguous command %s, which one of (%L) did you mean?' % [cmd, candidates]. },
                switch.
            },
            switch.
          }.
        }.
    }.
    ^c.
  }.
  ^my commands.
}.
Eval on: 'CommandCompletions' do: {
  ^my command_comps is my command_comps or: {
    ^Map new
      put: {:argstr var flags is Eval flags keys.
        ^argstr count either: {
          var flag is argstr head trim.
          flag startsWith: 'no-', either: { flag is flag skip: 3. } or: { }.
          ^flags filter: \:i:v v startsWith: flag, fmap: \:x x skip: flag length.
        } or: flags.
      } at: ':!f',
      put: {:argstr
        var vars is ['history'].
        ^argstr count either: {
            var f is argstr head trim.
            ^vars filter: \:_:x (x startsWith: f), fmap: \:x x skip: f length.
        } or: vars.
      } at: ':list',
      put: {:argstr
          ^argstr count either: {
              var path is argstr head split: ' ', last ~ ?>s|.*?((/*\w+)(/\w+)+/?).*|$1|<?.
              var path2 is path contains: '*', either: path or: path + '*'.
              ^(File expand: path2, fmap: (\:x x skip: path length)).
          } or: [].
      } at: ':!',
      put: {:filter
        filter is filter or: [''], last.
        ^(['all', 'show'] + (Array new fill: Reflect frameId with: \:i i toString)) filter: (\:_:x x startsWith: filter), fmap: \:x x skip: filter length.
      } at: ':!frame',
      put: {:filter ^Eval Commands keys filter: (\:_:x x startsWith: filter), fmap: \:x x skip: filter length.} at: 'generic'.
  }.
}.
Eval on: 'addMetaCommand:function:' do: {:name:fn
  Eval Commands put: fn at: name.
}.
Eval on: 'doMeta:' do: {:str:ptr
  var cmd is 'h'.
  var args is ''.
  str trim findPattern: '(\\W?\\w+|\\W)(\\s+(.*))?' do: {:parts cmd is parts @ 1. args is parts count > 2 either: {^parts @ 3.} or: ''.}.
  var cmds is Eval Commands.
  var unknownMetaCommandHandler is my unknownMetaCommandHandler.
  ^{
    ^cmds get: cmd, or: {
      ^cmd = '!'
        either: { ^(\:x Shell call: x). }
        or: {
          ^unknownMetaCommandHandler[cmd, args].
        }.
    }, applyTo: args.
  } catch: {:e
    ^'Exception was thrown while evaluating `${{str}}$\': $$e'.
  }, run.
}.
Eval on: 'unknownMetaCommandHandler:' do: {:hnd my unknownMetaCommandHandler is hnd. }.
Eval unknownMetaCommandHandler: {:cmd
  ^'Invalid meta-command \':%s\'.\n' % [cmd] + (Eval doMeta: 'h').
}.
Eval on: 'metaCompletion:' do: {:m
  var meta is m head.
  var argstrs is m tail.
  var cmds is Eval CommandCompletions.
  ^cmds at: meta, or: {
      argstrs is meta skip: 1.
      ^cmds at: 'generic'.
  }, applyTo: argstrs.
}.

Eval on: 'evaluate:' do: { :str
  my errd is False.
  var eval_result_x is Nil.
  var evalContext is my evaluationContext.
  var f is (str at: 0, = ':')
    either:
      ({ ^eval_result_x is Eval doMeta: (str skip: 1). } catch: {:e Eval handleException: e.})
    or:
      ({
          ^(str startsWith: 'import') not
            either: ({
                ^Reflect run: {:str ^str eval.} inContextAsMain: evalContext arguments: [str].
                } catch: {:e Eval handleException: e. ^Nil.}
            ) or: ({
                ^str eval.
                } catch: {:e Eval handleException: e. ^Nil.}).
        }).
    ^(Eval getFlag: 'jsonout') either: { ^Json serialize: [(f toString replace: '\\' with: '\\\\'), (Json serialize: [(Eval errored?), (Eval lastError), (Eval trace)])]. } or: {^f.}.
}.

Eval on: 'addFile:named:' do: {:str:fname
  var varname is fname split: '.' max: 1, head.
  Reflect run: {:fname:ctx:str ('var %s is {
    Eval statsb: 0, statsa: 0, exectime: 0.
    Reflect run: {:str str eval.} inContext: const ctx arguments: [const str].
  }' % [fname]) eval. } inContextAsMain: my evaluationContext arguments: [varname, my evaluationContext, '{\n $$str \n}'].
}.
Eval on: 'pushHist:' do: {:h
  my history push: h.
}.
Eval on: 'executeLast:' do: {:n
  ^me evaluate: (my history @ n).
}.
Eval on: 'getHistory' do: {^my history.}.

Eval on: 'queryState:' do: {:query
    ^(((query countOf: '\'') - (query countOf: '\\\'')) even) & ((query countOf: '{') = (query countOf: '}')) & ((query countOf: '[') = (query countOf: ']')).
}.

Eval init.
Eval setArgs: (Array new fill: Program argCount with: {:i ^Program argument: i.}).
Eval onlyRelevantArgs.

#arguments that were not consumed
var args is Array new.

#global vars for evaluator
var it is Nil.
var _  is Nil.
var __ is Nil.

Eval on: 'tryNumrify:' do: {:s
  var r is s.
  {r is s toNumber.} catch: {r is s.}, run.
  ^r.
}.


Eval on: 'flatten:' do: {:list
  var lst is Array new.
  list each_v: {:l
    (Reflect isObject: l linkedTo: Array) either: {
      lst is lst + (Eval flatten: l).
    } or: {
      lst push: l.
    }.
  }.
  ^lst.
}.

Eval on: 'instrument' do: {
  Reflect globalInstrument: me tryDebug.
  Reflect enableInstrumentation.
}.

Eval on: 'breakFor:message:' do: {:o:m
  my breakpoints put: True at: (o &responder: m).
}.

Eval on: 'hasBreakPoint:message:' do: {:object:message
  ^my breakpoints at: (object &responder: message), or: my stepDebug.
}.
Eval on: 'tryDebug' do: {:self
  var ctx is my evaluationContext.
  ^{:object:message:args
    var this is me.
    var eval is const self.
    (Reflect isInFrame: const ctx) ifFalse: {^this.}.
    var bp is eval hasBreakPoint: object message: message.
    ^bp either: {
        ^eval debugRepl: [this, object, message, args].
        } or: {
          ^this.
        }.
  }.
}.

Eval on: 'allTheNames' do: {
  ^(Eval Commands keys fmap: {:i ^':' + i.}) + ['var', 'my', 'is'] + (Eval flatten: my evaluationContext keys) + (HashSet new addAll: (Eval flatten: Reflect getContext), toArray).
}.

Eval on: 'allTheNames:' do: {:obj
  obj id = import id ifTrue: {
    # SPeCIAl CaSe
    ^[
      \import,
      {:path-or-m
        var meths is Reflect getMethodsOf: import.
        var pml is path-or-m lower.
        # Early exit in case it's not a path...probably
        meths is meths filter_v: {:meth
          ^meth lower startsWith: pml.
        }.
        meths count > 0 ifTrue: { ^meths. }.
        # It's a path...maybe
        var paths is path-or-m split: '/'.
        path-or-m endsWith: '/', ifTrue: { paths push: ''. }.
        var path is paths last lower.
        var pathv is paths init join: '/'.
        ^import searchPaths fmap: {:spath
          var dir is File new: spath + '/' + pathv.
          dir exists ifFalse: { ^[]. }.
          ^File list: dir path,
            filter_v: {:v
              ^ (['.', '..'] contains: v @ 'file', not)
                  `and`
                (v @ 'type' = 'folder')
                  `or`
                ( (v @ 'type' = 'file')
                    `and`
                  (v @ 'file' endsWith: '.ctr')
                ). },
            fmap: {:value ^value at: 'file'. },
            filter_v: {:x ^x lower startsWith: path. },
            fmap: {:x
              x endsWith: '.ctr',
                ifTrue: { ^ (pathv length > 0 either: pathv + '/' or: '') + (x from: 0 to: x length - 4). }
                ifFalse: { ^(pathv length > 0 either: pathv + '/' or: '') + (x).}.
            }.
        }, sum.
      }
    ].
  }.
  ^obj isNil not either: {^[\method, (Reflect getMethodsOf: obj)].} or: {^[\object, (Eval allTheNames)].}.
}.

Eval on: 'togglePasteMode' do: {
  me toggleFlag: 'highlight'.
  me toggleFlag: 'paste'.
}.

# parse arguments
var tidyIndentOptions is Map new.
{ ^(Eval argCount > 0). } whileTrue: {
    # get an option
    var opt is Eval shiftArgs.
    args push: opt.
    # when passed -h, show help, then exit.
    (frozen select_arg_q is case: '-h' do: {
        args pop. #consume option.
        Eval display/green write: 'Citron Evaluator.\n', resetColor.
        var P is Eval display.
        P on: 'indent:write:' do: {:self:i:w self write: ('  ' * i), write: w. }.
        P indent: 1 write: 'Eval mode help:', brk.
        P cyan indent: 1 write: 'Eval namespace', resetColor brk.
        P magenta indent: 2 write: '[Eval] setPrompt: [String] ', resetColor write: '-- Sets the prompt.', brk.
        P magenta indent: 2 write: '[Eval] setColor: [String] ', resetColor write: '-- sets the color of the output.', brk.
        P magenta indent: 2 write: '[Eval] getHistory ', resetColor write: '-- returns the 100 last commands.', brk.
        P magenta indent: 2 write: '[Eval] executeLast: [Number] ', resetColor write: '-- evaluates the Nth element of the history list.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServer ', resetColor write: '-- starts an eval server in the background. returns the port.', brk.
        P magenta indent: 2 write: '[Eval] startEvalServerOnPort: [Number] ', resetColor write: '-- same as startEvalServer, with the port specified.', brk.
        P magenta indent: 2 write: '[Eval] end ', resetColor write: '-- Ends the eval.', brk.
        P indent: 1 write: 'Evaluates expressions in a single context.', brk.
        P indent: 1 write: 'Since all expressions are in single lines, pragma oneLineExpressions is active,', brk.
        P indent: 1 write: 'Hence ending expressions with a dot (.) is not required.', brk.
        P indent: 1 write: 'All the args that were not consumed are in the variable `args`.', brk.
        P cyan indent: 1 write: 'Program arguments\n',
          resetColor indent: 2 write: '-p : set the prompt\n',
          indent: 2 write: '--pc : set the prompt continuation\n',
          indent: 2 write: '-c : set the result color\n',
          indent: 2 write: '-h : show this help\n',
          indent: 2 write: '-f : evaluate file. many can be passed. All the files get added as runnable blocks (fully-qualified path without extensions)\n',
          indent: 2 write: '-F<[no-]flag> : enables the passed flag\n',
          indent: 2 write: '--Fs : display all the available flags\n',
          indent: 2 write: '--Fsel : allow the user to pick from available flags via a terminal selection menu\n',
          indent: 2 write: '--meta <command> : execute a metacommand (sans the initial :)\n',
          indent: 2 write: '-e : evaluate expression and exit, all args after the expr will be passed to the code as var `args`\n',
          indent: 2 write: '--qe : evaluate expression without printing the value, then continue, all args after the expr will be passed to the code as var `args`\n',
          indent: 2 write: '-v : print version information and exit\n',
          indent: 2 write: '--tidy : [Experimental] try to tidy up the given file and write it back out to stdout\n',
          indent: 3 write: '-ml <int> : set max line length for --tidy\n',
          indent: 3 write: '-il <int> : set indent length in spaces for --tidy\n',
          indent: 3 write: '-pk : enable parentesize_kwmsgs for --tidy\n',
          indent: 2 write: '-s <port>: start a evaluation server on the specified port (Forked and the current process will be killed. pidfile at ~/.ctrpid.pid)\n',
          indent: 2 write: '-m <executable module> <modu_arg>* : Execute an executable module (at Library/Executable)\n',
          indent: 2 write: '--import <module_names_colon_sep> : preload modules separated by colons\n',
          indent: 2 write: '--pid <pidfile>: set the pid file. value is ignored unless [-s <port>] comes after\n',
          indent: 2 write: '--no-logo : don\'t display the ascii logo, use normal text instead\n',
          indent: 2 write: '--interactive-print : Use this object instead of `Pen\' to print values\n',
          indent: 2 write: '--interactive-output : Use this object instead of `Pen\' to print output\n',
          indent: 2 write: '--evaluator-object <symbol> : use this object\'s ::\'evaluate:\' responder to eval things\n',
          indent: 2 write: '--completer-object <symbol> : use this object\'s ::\'complete\' responder to complete things\n',
          indent: 2 write: '--highlight-file <file|-> : highlight the file (or stdin) and quit\n',
          indent: 2 write: '--assume-non-tty : Assume the terminal is not a tty\n',
          indent: 2 write: '--terminal-width <int> : Set the perceived terminal width (this will be automatically determined unless --assume-non-tty is passed)\n',
          indent: 2 write: '--without-signals : Disable signal processing\n',
          indent: 2 write: '--without-history : Disable recording of history\n',
          indent: 2 write: '--history-dir <dir> : Save the history in dir/ctrhist\n',
          indent: 2 write: '--update-stdlib -- Update the stdlib from alimpfard/citron_standard_library\n',
          indent: 2 write: '--update-stdlib-from <path> -- Update the stdlib from the given path\n',
          indent: 2 write: '--clear-errors : show tips for some common errors\n',
          indent: 2 write: '--html-colors : output html for syntax highlighting\n',
          magenta indent: 1 write: 'Any other option will be consumed and dumped into the `args` array.', brk.
        P green write: 'default imported modules in eval are:',
          cyan indent: 1 write: (import __loaded_modules keys reverse join: ' ') ~ 's/\\s|^/\\n+ /g'.
        P resetColor brk.
        Program exit.
    # when passed -p, get the next arg, and set the prompt to that.
    }, case: '-p' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-p requires an arg.'. }.
        Eval setPrompt: value.
    # when passed -pc, get the next arg, and set the continuation prompt to that.
    }, case: '--pc' do: {
        args pop. #consume option..
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '--pc requires an arg.'. }.
        Eval setContinuation: value.
    # when passed -c, get the next arg, and set the result color to that.
    }, case: '-c' do: {
        args pop. #consume option.
        var value is Eval shiftArgs.
        (value isNil) ifTrue: { thisBlock error: '-c requires an arg, valid arguments are: \n\t' + (((Eval allowedColors) split: '|') join: '\n\t'). }.
        Eval setColor: value.
    }, case: '-f' do: {
        args pop. #consume option.
        var file is Eval shiftArgs.
        (file isNil) ifTrue: { thisBlock error: '-f requires a file name.'. }.
        Eval addFile: (File new: file, read) named: file.
    }, case: '--Fs' do: {
        args pop. #consume option.
        Eval display/writeln: (Eval flags keys join: '\n').
        Program exit.
    }, case: '--Fsel' do: {
        import Library/Utils/CLISelectMenu: \*.
        var keys is Eval flags keys.
        var res is MultiSelectMenu
          new: keys
          pagesize: 5
          preSelected: (Eval flags keys filter: \:_:k Eval flags at: k),
        request.
        keys each_v: {:key
          res contains: key, ifTrue: {
            Eval enableFlag: key.
          } ifFalse: {
            Eval disableFlag: key.
          }.
        }.
    }, case: '--meta' do: {
        args pop.
        Eval doMeta: Eval shiftArgs.
    }, case: '-ml' do: {
        args pop.
        tidyIndentOptions put: (Eval shiftArgs toNumber) at: 'max_line_length'.
    }, case: '-il' do: {
        args pop.
        tidyIndentOptions put: (Eval shiftArgs toNumber) at: 'indent_length'.
    }, case: 'pk' do: {
        args pop.
        tidyIndentOptions put: True at: 'parenthesize_kwmsgs'.
    }, case: '--tidy' do: {
        args pop.
        var fname is Eval shiftArgs.
        fname isNil ifTrue: { thisBlock error: '--tidy requires an argument'. }.
        var code is Nil.
        fname = '-' ifTrue: {
            code is Program input.
        } ifFalse: {
            code is File new: fname, read.
            Pen writeln: '# File $$fname'.
        }.
        import Library/AST/ast2ctrcode: 'ast2ctrcode'.
        var options is tidyIndentOptions.
        Pen writeln: ast2ctrcode[(AST parse: code), 0, options].
        Program exit.
    }, case: '-e' do: {
        args pop. #consume option..
        var value is Eval shiftArgs rightTrim.
        (value isNil) ifTrue: { thisBlock error: '-e requires an argument.'. }.
        import
            Library/Utils/Shell: \*
            Library/Control/MethodResolve: \*
        .
        Reflect addGlobalVariable: '%0'.
        %0 is value.
        { ^(Eval argCount > 0). } whileTrue: { args push: Eval shiftArgs. }. #consume all other arguments.
        args imap: {:i:n Reflect addGlobalVariable: '%' + (i + 1). Reflect set: '%' + (i + 1) to: (Eval tryNumrify: n).}.
        Reflect addGlobalVariable: '%_'.
        %_ is args.
        value endsWith: '.', ifFalse: { value +=: '.'. }.
        value is '{ ^$$value }'.
        var val is (Eval evaluatorObject evaluate: value) run.
        val isA: Array, ifTrue: {
          Eval display/write: val join. # convert to lines
        } ifFalse: {
          val isA: Generator, ifTrue: {
            val each_v: {:v
              Eval display/write: v.
            }.
          } ifFalse: {
            Eval display/write: val.
          }.
        }.
        Program exit.
    }, case: '--qe' do: {
        args pop. #consume option..
        var value is Eval shiftArgs rightTrim.
        (value isNil) ifTrue: { thisBlock error: '--qe requires an argument.'. }.
        Reflect addGlobalVariable: '%0'.
        %0 is value.
        value endsWith: '.', ifFalse: { value +=: '.'. }.
        value is '{ $$value }'.
        (Eval evaluatorObject evaluate: value) run.
    }, case: '-v' do: {
        Eval display/writeln: 'Citron Version ' + Reflect version.
        Eval display/writeln: 'Built with the extension prefix of ' + File extensionsPath.
        Eval display/writeln: 'Compiled with ' + Reflect compilerInfo.
        Program exit.
    }, case: '-V' do: {
        Eval display/writeln: 'Citron'.
        Eval display/writeln: '[%L]' % [(Reflect version split: '.')].
        Program exit.
    }, case: '--pid' do: {
      args pop.
      var f is Eval shiftArgs.
      (f isNil) ifTrue: { thisBlock error: '--pid requires an argument <pidfile>'. }.
      PIDFILE is f.
    }, case: '-s' do: {
      args pop.
      var f is Eval shiftArgs toNumber.
      (f <=: 0) ifTrue: { thisBlock error: 'Invalid port specified: $$f'. }.
      Eval enableFlag: 'jsonout'.
      Eval startEvalServerOnPort: f.
      Program exit.
    }, case: '-m' do: {
      args pop.
      var mod is Eval shiftArgs.
      (mod isNil) ifTrue: { thisBlock error: 'no module to run?'. }.
      var args is Eval args.
      import respondTo: 'Library/Executable/%s:' % [mod] and: ['Main'].
      { Main applyTo: args. } catch: {:e Eval display/red writeln: e, resetColor.}, run.
      Program exit.
    }, case: '--import' do: {
      args pop.
      var mod is Eval shiftArgs.
      (mod isNil) ifTrue: { thisBlock error: 'Expected to get a list of fully qualified module names for --import'. }.
      mod split: ':', each_v: {:mod
        import respondTo: mod.
      }.
    }, case: '--no-logo' do: {
      args pop.
      display_logo is False.
    }, case: '--interactive-print' do: {
      args pop.
      var obj is Eval shiftArgs.
      obj is Eval evaluatorObject evaluate: obj, or: \:_ thisBlock error: '--interactive-print requires an argument'.
      Eval display: obj.
    }, case: '--interactive-output' do: {
      args pop.
      var obj is Eval shiftArgs.
      obj is Eval evaluatorObject evaluate: obj, or: \:_ thisBlock error: '--interactive-output requires an argument'.
      Eval print: obj.
    }, case: '--evaluator-object' do: {
      args pop.
      var obj is Eval shiftArgs.
      obj is Eval evaluate: obj, or: \:_ thisBlock error: '--evaluator-object requires an argument'.
      Reflect object: obj hasOwnResponder: 'evaluate:', ifFalse: {
        thisBlock error: 'argument to --evaluator-object must respond to \'evaluate:\' ($$obj does not)'.
      }.
      Eval evaluatorObject: obj.
    }, case: '--completer-object' do: {
      args pop.
      var obj is Eval shiftArgs.
      obj is Eval evaluate: obj, or: \:_ thisBlock error: '--completer-object requires an argument'.
      Reflect object: obj hasOwnResponder: 'complete:withToc:', ifFalse: {
        thisBlock error: 'argument to --completer-object must respond to \'complete:withToc:\' ($$obj does not)'.
      }.
      Eval completerObject: obj.
    }, case: '-F' do: {
      args pop.
      var opts is Eval shiftArgs or: '', reSplit: '(,|/)(\\s*)'.
      opts each: {:i:flag
        (flag = '') ifTrue: { errPen yellow writeln: '[Warn]: empty -F flag index#$$i was ignored', resetColor. }.
        Eval modifyFlags: flag.
      }.
    }, case: '--highlight-file' do: {
      var files is Eval shiftArgs or: '-', reSplit: '(\\s+)'.
      var ishtml is Eval getFlag: 'html_colors'.
      var fix_html is {:s
        ishtml ifFalse: { ^s. }.
        ^'<pre>%s</pre>' % [s ~ 's:\\n:<br/>:g'].
      }.
      ishtml ifTrue: {
        Pen write: '<style>a{margin-right:2px;}</style>'.
      }.
      files each_v: \:f f = '-' either: {
          var s is (Highlight highlight: (Program input) html: ishtml).
          Pen writeln: (ishtml either: { ^fix_html[s]. } or: s).
      } or: {
        var s is (Highlight highlight: (File new: f, read) html: ishtml).
        Pen writeln: (ishtml either: { ^fix_html[s]. } or: s).
      }.
      Program exit.
    }, case: '--assume-non-tty' do: {
      args pop.
      Eval disableFlag: 'intty'.
    }, case: '--terminal-width' do: {
      args pop.
      var w is Eval shiftArgs.
      {
        w is w toNumber.
        (w <=: 0) ifTrue: { thisBlock error: 0. }.
      } catch: { thisBlock error: '--terminal-width requires an integer > 0, not $$w'. }, run.
      TerminalWidth is w.
    }, case: '--without-signals' do: {
      args pop.
      Eval disableFlag: 'processig'.
    }, case: '--without-history' do: {
      args pop.
      Eval disableFlag: 'history'.
    }, case: '--history-dir' do: {
      args pop.
      var dir is Eval shiftArgs.
      dir isNil ifTrue: {
        thisBlock error: '--history-dir expects a directory argument'.
      }.
      Eval histdir: dir.
    }, case: '--clear-errors' do: {
      args pop.
      Eval enableFlag: 'clear_errors'.
    }, case: '--html-colors' do: {
      args pop.
      Eval enableFlag: 'html_colors'.
      import Library/Utils/Colors/HTML.
    }, case: '--update-stdlib' do: {
      args pop.
      import Library/Utils/update-self: \*.
      update-stdlib run.
      Program exit.
    }, case: '--update-stdlib-from' do: {
      args pop.
      var path is Eval shiftArgs.
      path isNil ifTrue: {
        thisBlock error: '--update-stdlib-from expects a github repository name in form of `owner/repo-name\''.
      }.
      import Library/Utils/update-self: \*.
      update-stdlib applyTo: path.
      Program exit.
    }, default: {
      (opt startsWith: '-') & (opt startsWith: '--', not) ifTrue: {
        args pop.
        opt skip: 1, reverse characters each_v: \:c args push: '-' + c.
      }.
    }) switch: opt. # do not consume any other option.
}.

Eval break ifTrue: { Program exit. }.

(Eval getFlag: 'intty') ifTrue: {
  import
    Library/Foreign/C/NamedStruct
    .
  import Library/Foreign/C/C_Types: ['c_int', 'c_ptr', 'c_short'].
  import Library/Foreign/C/errno: 'g_strerror'.

  _ioctl is CTypes loadLibrary: Nil, ioctl.
  _ioctl_ty is CIF new setABI: 0 return: c_int argTypes: [c_int, c_int, c_ptr].
  wsize is NamedStruct new initAs: 'ssssssss' names: ['row', 'col', 'x_pixel', 'y_pixel'].
  wsize struct allocate.

  winsize is {:_
    var __eval_ret is _ioctl_ty call: _ioctl withArgs: [0, 0x5413, (wsize struct)].
    (__eval_ret !=: 0) ifTrue: { thisBlock error: g_strerror run. }.
    TerminalWidth is (wsize memberCol - 10) max: 10.
    ^[wsize memberRow, wsize memberCol, wsize memberXPixel, wsize memberYPixel].
  }.

  TerminalWidth is 85.
  Eval display/writeln: 'Terminal: %sx%s - %sx%s' % winsize run.

  var stopexec is {
    thisBlock error: 'Interrupted'.
  }.

  (Eval getFlag: 'processig') ifTrue: {
    import Library/Foreign/C/Signal: 'Signal'.
    # This will blow up on libffi <3.3
    # investigate (related to #8)
    Signal new
      handle: 'SIGINT'   with: stopexec,
      handle: 'SIGWINCH' with: winsize.
  }.
}.

Eval getFlag: 'history', ifTrue: { Eval initHistory. }.

display_logo
  either: {Eval display/writeln: (Colors % [logo, GREEN_COLOR, ITALIC_EFFECT] % ['Project Citron', Reflect version, Reflect compilerInfo]).}
  or: {
    Eval display/green write: ?>Project Citron : The Programming Language (V<?, write:(Reflect version) + ')', resetColor brk
    write:
    'Eval Mode, parameters related to eval are in the Eval namespace.\n' +
    'run with \'-h\' to read the eval mode help.\n'.
  }.

Eval on: 'redraw:at:comment:' do: {:inp:cursor:cmt
  cursor -=: inpbrk.
  inp is inp from: inpbrk to: inp length.
  var ctn is Eval prompt.
  ctn is inp length > ((var twext is TerminalWidth run - (ctn length))) either: (Eval continuation) or: ctn.
  twext -=: cursor.
  twext -=: cmt length.
  twext < 0 ifTrue: {
    cmt is ''.
  }, else: {
    cmt is '\x1b[%dC%s\x1b[%dD' % [twext, cmt, twext + cmt length].
  }.
  Eval display/clearLine.
  inp length > 1 ifTrue: {
    var diff is 0.
    var iinp is (cursor > (var first_visible is (inp length - TerminalWidth run - (ctn length) max: 0))) either: { ^inp skip: first_visible - 2. } or: { var tdiff is TerminalWidth run - (ctn length). var f is inp skip: cursor - 1. diff is f length - tdiff. ^f from: 0 length: tdiff. }.
    (Eval getFlag: 'highlight') ifTrue: {iinp is Highlight highlight: iinp.}.
    Eval display/cyan write: ctn, resetColor.
    Eval display/write: '%s%s' % [iinp, ('\b' * (inp length - cursor - diff - 1 max: 0, min: inp length))].
  }, else: {
    Eval display/cyan write: ctn, resetColor write: inp.
  }.
  (cmt length > 0) ifTrue: { Eval display/yellow write: cmt, resetColor. }.
}.

Eval genAccessors: ['exectime', '__eval_ret', 'statsb', 'statsa'].

Eval on: 'repl' do: {:self
  {^True.} whileTrue: { self read_eval_print: self prompt. }.
}.

Eval on: 'enableDebugStuff' do: {
  my debug is True.
}, on: 'disableDebugStuff' do: {
  my debug is False.
  my stepDebug is False.
  my end is False.
}.

Eval on: 'debugRepl:' do: {:self:stuff
  Pen writeln: 'Break on %s::\'%s\' (%L)' % stuff tail.
  var prompt is '%s %s(%s)%s' % (stuff tail + [self prompt]).
  var inp is ''.
  var _ is Nil.
  var __ is Nil.
  var it is Nil.
  var stderr is File special: 'stderr'.
  var errPen is Pen for: stderr.
  var enterRepeat is True.
  var inBlock is 0.
  var inBlockNew is 0.
  enableDebugStuff.
  my returnValue push: stuff head.
  {^True.} whileTrue: { self read_eval_print: prompt. }.
  disableDebugStuff.
  ^my returnValue pop.
}.

Eval on: 'complete:withToc:' do: {:last_toc:toc
  var candidates is Eval allTheNames: (
    {
      ^Reflect getObject: (
        ['my', 'var'] contains: last_toc,
          either: Nil
          or: last_toc).
    } catch: {
      ^Nil.
    }, run).
  var resolver is Nil.
  var skipthis is False.
  candidates head = \import ifTrue: {
    resolver is candidates @ 1.
  } ifFalse: {
    resolver is {:toc ^candidates @ 1 filter: {:_:i ^i lower startsWith: toc lower.}. }.
    skipthis is candidates head = \object.
  }.
  ^resolver[toc].
}.

Eval on: 'complete' do: {
  var candidate is 'Nil'.
  var toc is inp trim reSplit: '\\s+|\\b|(?=[\\]})])'.
  toc is toc count = 0 either: '' or: { ^toc last. }.

  last_was_comp ifTrue: {
    # Pen writeln: [last_comp_entry, '\n'].
    var toremove is last_comp_entry length - last_comp_init length.
    Pen write: '\b \b' * toremove.
    inp is inp removeFrom: (cursor - toremove) to: cursor.
    cursor is (cursor - toremove) max: 0.
  }.
  # toc is last_was_comp either: last_comp_entry or: toc.
  last_comp_entry_len is last_comp_entry length.

  var flipper is OneGateFlipper new.
  last_toc is inp trim
    or: 'Nil',
    reSplit: '\\s+',
    filter: {:_:v
      (v endsWith: ':')
        ifTrue: {
          flipper set.
          ^False.
        }.
      ^(
        (v endsWith: ':') | (flipper get)
      ) not |
        (v containsPattern: ?>(-?(0[xXcC])?[\d]+(\.[\d]+)?)|(\'$)|(\]|\})$<?).
    }.
  last_toc is (last_toc count) >=: 2, either: {
    toc is last_toc last.
    ^last_toc init last.
  } or: {
    ^last_toc count = 0 either: 'Nil' or: {
      ^last_toc head.
    }.
  }.
  last_toc containsPattern: ?>^(-?(0[xXcC])?[\d]+(\.[\d]+)?)$<?, ifTrue: { last_toc is 'Number'. }.
  last_toc containsPattern: ?>(\'|\?>)$<?, ifTrue: { last_toc is 'String'. }.
  last_toc containsPattern: ?>\]\s*$<?, ifTrue: { last_toc is 'Array'. }.
  last_toc containsPattern: ?>\}\s*$<?, ifTrue: { last_toc is 'CodeBlock'. }.
  var candidates is Eval completerObject complete: last_toc withToc: toc.
  candidates count !=: 0, ifTrue: {
    have_context is True.
    candidate is candidates @ (last_comp_index is (last_comp_index +=: 1) >=: (candidates count), either: 0 or: last_comp_index).
    var uniq is comp_set addAll: candidates, toArray.
    uniq each_v: {:k comp_set remove: k. }.
    var uid is uniq indexOf: candidate.
    linesp is generate_context_menu applyTo: uniq and: uid.
    cmt is (var iis is '[from %s]' % [last_toc]).
    last_comp_rewind is iis length.
    toc length > cursor ifTrue: {
        cmt is 'not enough space, make query bigger'.
        last_comp_init is ''.
        last_comp_entry is ''.
        last_comp_entry_len is 0.
    } ifFalse: {
      toc length times: {:i
        var pos is cursor - (toc length - i).
        pos >=: inp length, ifTrue: {
          inp +=: candidate @ i.
        } ifFalse: {
          inp put: candidate @ i at: pos.
        }.
      }.
      inp is inp insert: (candidate skip: toc length) at: cursor.
      cursor +=: candidate length - toc length.
      last_comp_init is toc.
      last_comp_entry is candidate.
      last_comp_entry_len is last_comp_entry length.
    }.
  } ifFalse: {
    cmt is ncmessage.
  }.
  last_was_comp is True.
}.

Eval on: 'probeSearch:offset:' do: {:&term:&sindex
  var offset is False.
  (sindex < 0) | (sindex > my history count) ifTrue: {
    sindex -=: sindex.
  }.
  my history viewFrom: sindex, each: {:&off:&entry
    entry contains: term, ifTrue: {
      sindex +=: off.
      offset is True.
      True break.
    }.
  }.
  ^offset.
}.

Eval on: 'substituteSearchResult' do: {
  Eval disableFlag: 'searching'.
  Eval disableFlag: 'searchfailed'.
  clear_next_line[1].
  inp is searchResult.
  cursor is searchResult indexOf: searchTerm.
  searchIndex is 0.
}.

Eval on: 'read_eval_print:' do: ({:prompt
  var hindex is me getHistory count.
  var ncmessage is ' <- No completion'.
  var stdin is File special: 'stdin'.
  inp is Eval nextInput.
  inp isNil ifTrue: {
    inp is ''.
  } ifFalse: {
    Eval nextInput: Nil.
  }.
  # break the repl when `end` is True.
  Eval break break.
  Eval display/cyan write: prompt, resetColor.

  var last_was_comp is False.
  var last_comp_entry is ''.
  var last_comp_index is -1.
  var last_comp_rewind is 0.
  var last_toc is 'Object'.
  var done is False.
  var cursor is inp length.
  var multichar_in is Array new.
  inBlock is 0.
  inBlockNew is 0.
  Eval endBlock.
  var lastEscape is False.
  var justInEscape is False.
  var inString is False.
  var inpbrk is 0.
  var last_comp_entry_len is 0.
  var ce_idx is 0.
  var cmt is ''.
  var comp_set is HashSet new.
  var have_context is False.
  var last_comp_init is ''.
  var inc is ''.
  var searchIndex is 0.
  var searchTerm is ''.
  var searchResult is ''.

  {^done & (inBlock = 0).} whileFalse: {
    cmt is ''.
    var select_toplevel_inc is (frozen select_toplevel_inc is Object
     case: '\xd' do: {#<Enter>
      Eval getFlag: 'searching', ifTrue: {
        Eval substituteSearchResult.
      }.
      clear_next_line applyTo: linesp.
      inBlock is inBlockNew.
      (inp !=: '') ifTrue: {
        have_context ifFalse: {
          inp is inp findPattern: ?>(?:^\s*((?::{)+)|((?::}\s*)+)\s*$)<? do: {:groups
            var s is groups at: 0, replace: ':' with: ''.
            var s0 is s at: 0, = '{' either: 1 or: -1.
            inBlock is inBlock + (s0 * s length) max: 0.
            cursor -=: (groups at: 0, length).
            ^''.
          }.
          inp length > 0 ifTrue: {
            (inp containsPattern: ?>^\s*:[^{}]<?) ifTrue: {
              done is True.
            }, else: {
              (inp containsPattern: ?>\.\s*$<?, not) & (inBlock = 0) ifTrue: {
                # nothing?
              }.
              done is inBlock = 0.
            }.
            inBlock !=: 0, ifTrue: { Eval newBlock. Pen brk. inp +=: '\n'. inpbrk is inp length. cursor +=: 1.}.
          }, else: { Pen brk. done is True. }.
        }.
        have_context is False.
      }.
    }, case: '\x3' do: {#<^C>
      Eval getFlag: 'searching', ifTrue: {
        Eval substituteSearchResult.
        cmt is '<Cancelled search>'.
      } ifFalse: {
        clear_next_line applyTo: linesp. have_context is False.
        inp is ''.
        cursor is 0.
        inBlock is 0.
        inBlockNew is 0.
        cmt is '<Broke block>'.
        # Pen red writeln: 'Interrupted', resetColor.
        # done is True.
      }.
    }, case: '\x4' do: {#^D
      Program exit.
    }, case: '\x12' do: {#^R -- backwards-search
      Eval getFlag: 'searching', ifTrue: {
        # prev-match
        var hist is Eval getHistory.
        searchIndex +=: 1.
        searchIndex > hist count ifTrue: {
          searchIndex -=: searchIndex.
        }.
        Eval probeSearch: searchTerm offset: searchIndex, ifTrue: {
          Eval disableFlag: 'searchfailed'.
          searchResult is hist @ searchIndex.
        } ifFalse: {
          Eval enableFlag: 'searchfailed'.
          searchResult is Nil.
        }.
      } ifFalse: {
        searchTerm is inp + ''.
        searchIndex -=: searchIndex.
        Pen writeln: searchIndex.
        Eval enableFlag: 'searching'.
      }.
    }, case: '\xc' do: {#^L -- clear screen
      Pen clear.
    }, case: '\b' do: {#<\b>
      Eval getFlag: 'searching', ifTrue: {
        searchTerm is searchTerm from: 0 length: searchTerm length - 1.
        ^Nil.
      }.
      clear_next_line applyTo: linesp. have_context is False.
      cursor > 0 ifTrue: {
        inp is inp removeFrom: (cursor - 1) to: cursor.
        cursor -=: 1.
        Eval display/write: '\b \b'.
      }, else: { Eval display/write: '\a'. }.
    }, case: '\x7f' do: {#<\b>
      Eval getFlag: 'searching', ifTrue: {
        searchTerm is searchTerm from: 0 length: searchTerm length - 1.
        ^Nil.
      }.
      clear_next_line applyTo: linesp. have_context is False.
      cursor > 0 ifTrue: {
        inp is inp removeFrom: (cursor - 1) to: cursor.
        cursor -=: 1.
        Eval display/write: '\b \b'.
      }, else: { Eval display/write: '\a'. }.
    }, case: '\x13' do: {
      var toc is (inp trim or: '  ') split: ' ', last.
      var recs is '%:L' % [' ', (Eval allTheNames filter: {:_:n ^n startsWith: toc.})].
      Eval display/cyan write: recs, resetColor.
      clear_next_line applyTo: linesp. have_context is False.
    }, case: '\x1b' do: { #<esc>
      Eval getFlag: 'searching', ifTrue: {
        Eval substituteSearchResult.
      }.
      # Eval redraw: inp at: cursor - 1 comment: '<escape>'.
      inc is stdin readUTF8Bytes: 1.
      (frozen select_inlevel_t is
           case: '\x5b' do: {
             inc is stdin readUTF8Bytes: 1.
             (frozen select_inlevel_q is
                 case: '\x41' do: { #Up Arrow
                  hindex > 0 ifTrue: {
                    cursor is (inp is Eval getHistory at: (hindex is hindex - 1)) length.
                  }.
                  clear_next_line applyTo: linesp. have_context is False.
              }, case: '\x42' do: { #Down Arrow
                  (hindex > 0) & (Eval getHistory count > 0) ifTrue: {
                    hindex +=: 1.
                    Eval display/write: '\b' * (inp length).
                    inp is Eval getHistory.
                    inp count <=: hindex, ifTrue: {hindex is inp count.}.
                    inp is inp at: hindex - 1.
                    cursor is inp length.
                  }, else: {
                    hindex is 0.
                    Eval display/write: '\b \b' * (inp length).
                    inp is ''.
                    cursor is 0.
                  }.
                  clear_next_line applyTo: linesp. have_context is False.
              }, case: '\x43' do: { #Right Arrow
                (cursor < inp length) ifTrue: {
                  cursor +=: 1.
                }, else: {Eval display/write: '\a'.}.
                clear_next_line applyTo: linesp. have_context is False.
              }, case: '\x44' do: { #Left Arrow
                (cursor > 0) ifTrue: {
                  cursor -=: 1.
                }, else: {Eval display/write: '\a'.}.
                clear_next_line applyTo: linesp. have_context is False.
              }, case: '\x31' do: { #Supposedly <ctrl>
                inc is stdin readUTF8Bytes: 3.
                  (inc = '\x3b\x35\x44') & (cursor > 0) ifTrue: { #^Left Arrow
                    var ct is inp from: 0 to: cursor.
                    var ct is ct trim.
                    ct at: ct length - 1, = ':' ifTrue: { ct is ct from: 0 to: ct length - 1. }.
                    ct is (ct reLastIndexOf: ?>\s|\'|(?<!^):\b|:$<?).
                    ct is ct equals: cursor - 1, either: ct - 1 or: ct.
                    cursor is ct + 1.
                  } ifFalse: {
                    (inc = '\x3b\x35\x43') ifTrue: { #^Right Arrow
                      var ct is (var ix is inp from: cursor to: (inp length), rightTrim) reIndexOf: ?>\s|\'|(?<!^):\b|:$<?, - 1.
                      ct is ct equals: 0, either: ct + 1 or: ct - 1.
                      cursor is cursor + ct + ((inp length) - (ix length)).
                    }.#, else: { Eval display/red write: inc. }.
                  }.
                  clear_next_line applyTo: linesp. have_context is False.
              }, default: {
                Pen writeln: inc toByteArray.
              }) switch: inc.
        }, case: '\x4f' do: {
            inc is stdin readUTF8Bytes: 1.
            (frozen select_inlevel_c is
                 case: '\x51' do: { #F2
                  clear_next_line applyTo: linesp. have_context is False.
                  Eval togglePasteMode.
              }
            ) switch: inc.
        }, case: '\xd' do: { #<Enter>
          inBlockNew +=: 1.
          True continue.
        }, case: '\x1b' do: { #<esc>
          inBlockNew is 0 max: inBlockNew - 1.
        }, default: {
        }
      ) switch: inc.
    }, default: {
      Eval getFlag: 'searching', ifTrue: {
        searchTerm +=: inc.
        ^Nil.
      }.
      have_context ifTrue: { clear_next_line applyTo: linesp. have_context is False. }.
      Eval getFlag: 'paste', ifTrue: {
        inp is inp insert: inc at: cursor.
        cursor +=: inc length.
      }
      ifFalse: {
        (frozen str_select_q is
          case: '\'' do: {
              inString either: {
                lastEscape ifFalse: { inString is False. }.
              } or: { inString is True. }.
          },
          case: '\\' do: {
            inString ifTrue: {
              lastEscape is lastEscape not.
              justInEscape is True.
            }.
            clear_next_line[1].
          },
          case: '#' do: {
            inString ifFalse: {
              cmt is Colors % ['comments are not allowed in eval', \red].
              inc is ''.
            }.
          },
          case: '{' do: {
            (inString not) ifTrue: {
              inBlockNew +=: 1.
            }.
          },
          case: '}' do: {
            (inString not) & (inBlockNew > 0) ifTrue: {
              inBlockNew -=: 1.
            }.
          },
          default: { lastEscape & inString ifTrue: {lastEscape is False.}. }) switch: inc.
          justInEscape ifFalse: { lastEscape is False. }.
          inp is inp insert: inc at: cursor.
          cursor +=: inc length.
          # Eval redraw: inp at: cursor comment: ''.
      }.
    }).
    Eval getFlag: 'searching', not ifTrue: {
      inc = '\t' ifTrue: {#<Tab>
          clear_next_line applyTo: linesp. have_context is False.
          comp_set clear.
          inp containsPattern: ?>^\s*:<?, either: {
            last_was_comp ifTrue: {
              inp is inp removeFrom: (cursor - last_comp_entry_len) to: cursor.
              cursor is (cursor - last_comp_entry_len) max: 0.
            }.
            var comps is Eval metaCompletion: (inp split: ' ' max: 1).
            comps count > 0 either: {
              comps count <=: ce_idx, ifTrue: { ce_idx is 0. }.
              # Pen writeln: comps.
              last_comp_entry is comps @ ce_idx.
              ce_idx +=: 1.
              last_comp_entry_len is last_comp_entry length.
              inp +=: last_comp_entry.
              cursor +=: last_comp_entry_len.
              last_was_comp is True.
            } or: { cmt is '<- No completion'. }.
          } or: {
            Eval complete.
          }.
      } ifFalse: {
        select_toplevel_inc switch: inc.
        last_was_comp is False.
      }.
      Eval redraw: inp at: cursor - 1 comment: (inBlock either: '%s%d' % ['%{', inBlock] or: cmt).
    } ifFalse: {
      select_toplevel_inc switch: inc.
      var hist is Eval getHistory.
      searchIndex -=: 1.
      Eval probeSearch: searchTerm offset: searchIndex, ifTrue: {
        Eval disableFlag: 'searchfailed'.
        searchResult is hist @ searchIndex.
      } ifFalse: {
        Eval enableFlag: 'searchfailed'.
        searchResult is ''.
      }.
      Eval redraw: searchResult at: 0 comment: (inBlock either: '%s%d' % ['%{', inBlock] or: cmt).
      move_cursor[0, (searchResult indexOf: searchTerm)].
      write_next_line['search> ' + searchTerm].
    }.
    # Eval display/write: inc toByteArray.
    done is (done & (inBlock = 0)).
    done break.
    inc is stdin readUTF8Byte.
  }.
  hindex is Eval getHistory count.
  # Eval display/cyan write: ' [cursor %d in (%s)]' % [cursor, (inp)], resetColor.
  (inp trim = '') ifTrue: {
    enterRepeat ifTrue: {
      inp is Eval getHistory or: ['Nil'], head.
    } ifFalse: {
        True continue.
    }.
  }.
  Eval getFlag: 'printvs', ifTrue: { Eval display/brk. }.
  # if it ends in a dot, get rid of it.
  inp is inp trim.
  inp endsWith: '.', ifTrue: {
    inp is inp from: 0 length: (inp length - 1).
  }.
  Eval statsb: 0, statsa: 0, exectime: 0.
  Eval getFlag: 'stats', either: {
    Eval statsb: Broom keptAlloc.
    Eval exectime: (Clock timeExecutionOf: { Eval __eval_ret: (Eval evaluatorObject evaluate: inp). }).
    Eval statsa: Broom keptAlloc.
  }
  or: {
    Eval __eval_ret: (Eval evaluatorObject evaluate: inp).
  }.
  Eval pushHist: inp.
  __ is _.
  _ is Eval __eval_ret.
  Eval errored? not ifTrue: {
    var printed is False.
    Eval getFlag: 'printvs', ifTrue: {
      Eval print message: Eval color arguments: [], write: var str is Eval __eval_ret toString.
      printed is str length > 0.
    }.
    Eval print/resetColor.
    Eval getFlag: 'ptype', ifTrue: {
      Eval print/yellow write: '%s=> (%s)%s' % [(printed either: ' ' or: ''), (Reflect strTypeOf: Eval __eval_ret, ~ 's/\\\\?\\\'//g'), (printed either: '' or: '\n')].
      Eval print/resetColor.
    }.
    Eval getFlag: 'stats', ifTrue: {
      var str is '%s(%s seconds (%d cycles), %s bytes)' % [(printed either: '\n' or: ''), Eval exectime / (Clock ticksPerSecond), Eval exectime, ((Eval statsa - Eval statsb) toString reverse reSplit: '(?<=\\G...)', join: ',', reverse)].
      Eval print/write: Colors % [str, GREEN_COLOR, ITALIC_EFFECT].
      printed ifFalse: { Eval print/brk. }.
    }.
    it is _.
    #Broom sweep. #Keep the darn pointers in memory
    Eval __eval_ret toString length > 0 ifTrue: { Eval display/brk. }.
  }.
}).# catch: {:e Eval handleInternalException: e.}).

Eval repl.
